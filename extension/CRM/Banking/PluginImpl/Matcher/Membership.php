<?php
/*-------------------------------------------------------+
| Project 60 - CiviBanking                               |
| Copyright (C) 2013-2015 SYSTOPIA                       |
| Author: B. Endres (endres -at- systopia.de)            |
| http://www.systopia.de/                                |
+--------------------------------------------------------+
| This program is released as free software under the    |
| Affero GPL v3 license. You can redistribute it and/or  |
| modify it under the terms of this license which you    |
| can read by viewing the included agpl.txt or online    |
| at www.gnu.org/licenses/agpl.html. Removal of this     |
| copyright header is strictly prohibited without        |
| written permission from the original author(s).        |
+--------------------------------------------------------*/


require_once 'CRM/Banking/Helpers/OptionValue.php';

/**
 * This matcher tries to reconcile the payments with existing memberships. 
 */
class CRM_Banking_PluginImpl_Matcher_Membership extends CRM_Banking_PluginModel_Matcher {

  /**
   * class constructor
   */ 
  function __construct($config_name) {
    parent::__construct($config_name);

    // read config, set defaults
    $config = $this->_plugin_config;
    if (!isset($config->threshold))          $config->threshold = 0.5;
    if (!isset($config->general_options))    $config->general_options = array();
    if (!isset($config->membership_options)) $config->membership_options = array();
  }

  /** 
   * Generate a set of suggestions for the given bank transaction
   * 
   * @return array(match structures)
   */
  public function match(CRM_Banking_BAO_BankTransaction $btx, CRM_Banking_Matcher_Context $context) {
    $config = $this->_plugin_config;
    $threshold = $config->threshold;
    $data_parsed = $btx->getDataParsed();

    // find potential contacts    
    $contacts_found = $context->findContacts($threshold, $data_parsed['name'], $config->lookup_contact_by_name);

    // with the identified contacts, look up matching memberships
    $memberships = $this->findMemberships($contacts_found, $btx, $context);

    // transform all memberships into suggestions
    foreach ($memberships as $membership) {
      $suggestion = new CRM_Banking_Matcher_Suggestion($this, $btx);
      if (isset($contact->general_options->suggestion_title)) {
        $suggestion->setTitle($contact->general_options->suggestion_title);  
      } else {
        $suggestion->setTitle(ts("Record as Membership Fee"));
      }

      $suggestion->setId("existing-$contribution_id");
      $suggestion->setParameter('membership_id', $membership['id']);
      $suggestion->setParameter('last_fee_id',   $membership['last_fee_id']);
      $suggestion->setProbability($membership['probability']);
      $btx->addSuggestion($suggestion);
    }

    // that's it...
    return empty($this->_suggestions) ? null : $this->_suggestions;
  }

  /**
   * Handle the different actions, should probably be handles at base class level ...
   * 
   * @param type $match
   * @param type $btx
   */
  public function execute($suggestion, $btx) {
    $membership_id = $suggestion->getParameter('membership_id');

    // TODO: Implement:
    // 1. create contribution
    // 2. connect to membership
    // 3. update status?

    $newStatus = banking_helper_optionvalueid_by_groupname_and_name('civicrm_banking.bank_tx_status', 'Processed');
    $btx->setStatus($newStatus);
    parent::execute($suggestion, $btx);
    return true;
  }

  /**
   * If the user has modified the input fields provided by the "visualize" html code,
   * the new values will be passed here BEFORE execution
   *
   * CAUTION: there might be more parameters than provided. Only process the ones that
   *  'belong' to your suggestion.
   */
  public function update_parameters(CRM_Banking_Matcher_Suggestion $match, $parameters) {
    // NOTHING to do...
  }

  /** 
   * Generate html code to visualize the given match. The visualization may also provide interactive form elements.
   * 
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return html code snippet
   */  
  function visualize_match( CRM_Banking_Matcher_Suggestion $match, $btx) {
    $smarty = CRM_Core_Smarty::singleton();

    // load the contribution
    $membership_id = $match->getParameter('membership_id');
    $last_fee_id   = $match->getParameter('last_fee_id');

    // LOAD entities
    // TODO: error handling
    $membership        = civicrm_api('Membership', 'getsingle', array('id' => $membership_id, 'version'=>3));
    $membership_type   = civicrm_api('MembershipType', 'getsingle', array('id' => $membership['membership_type_id'], 'version'=>3));
    $membership_status = civicrm_api('MembershipStatus', 'getsingle', array('id' => $membership['status_id'], 'version'=>3));
    $contact           = civicrm_api('Contact', 'getsingle', array('id' => $membership['contact_id'], 'version'=>3));
    $last_fee          = civicrm_api('Contribution', 'getsingle', array('id' => $last_fee_id, 'version'=>3));

    // calculate some stuff
    $last_fee['days']   = round((strtotime($btx->booking_date)-strtotime($last_fee['receive_date'])) / (60 * 60 * 24));
    $membership['days'] = round((strtotime($btx->booking_date)-strtotime($membership['start_date'])) / (60 * 60 * 24));
    $membership['percentage_of_minimum'] = round(($btx->amount / (float) $membership_type['minimum_fee']) * 100);

    // assign to smarty and compile HTML
    $smarty->assign('membership',        $membership);
    $smarty->assign('membership_type',   $membership_type);
    $smarty->assign('membership_status', $membership_status);
    $smarty->assign('contact',           $contact);
    $smarty->assign('last_fee',          $last_fee);
    return $smarty->fetch('CRM/Banking/PluginImpl/Matcher/Membership.suggestion.tpl');
  }

  /** 
   * Generate html code to visualize the executed match.
   * 
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return html code snippet
   */  
  function visualize_execution_info( CRM_Banking_Matcher_Suggestion $match, $btx) {
    $membership_id = $match->getParameter('membership_id');
    //$contribution_link = CRM_Utils_System::url("civicrm/contact/view/contribution", "action=view&reset=1&id=${contribution_id}&cid=2&context=home");
    return "<p>".sprintf(ts("This payment was associated with <a href=\"%s\">membership #%s</a>."), $contribution_link, $contribution_id)."</p>";
  }


  /**
   * This function will use the given parameters to find
   * all potential membership IDs with the contacts found.
   */
  protected function findMemberships($contact2probability, $btx, $context) {
    if (empty($contact2probability)) return array();

    $config = $this->_plugin_config;
    $memberships = array();
    $query_sql = $this->createSQLQuery(array_keys($contact2probability), $btx->amount, $context);
    $query = CRM_Core_DAO::executeQuery($query_sql);
    while ($query->fetch()) {
      $memberships[] = array(
        'id'            => $query->id,
        'contact_id'    => $query->contact_id,
        'last_fee_id'   => $query->last_fee_id
        // TO BE EXTENDED...
        );
    }

    // now rate all the memberships, and cut off the ones under the threshold
    $result = array();
    foreach ($memberships as $membership) {
      $probability = $this->rateMembership($membership, $context);
      if ($probability >= $config->threshold) {
        $result[] = $membership;
      }
    }

    return $result;
  }


  /**
   * This function will generate an SQL statement to
   * find all relevant memberships. It should also
   * provide all values necessary to rate the membership
   * for probability
   * 
   * the query itself is derived from the plugin's configuration
   * and will be cached.
   *
   * @return SQL string
   */
  protected function createSQLQuery($contact_ids, $amount, $context) {
    $cache_key = "matcher_membership_" . $this->_plugin_id . "_query";
    $query = CRM_Utils_StaticCache::getCachedEntry($cache_key);
    if ($query == NULL) {
      // NOT CACHED, build query
      $config = $this->_plugin_config;
      $base_query = "
      SELECT 
        civicrm_membership.id             AS id,
        civicrm_membership.contact_id     AS contact_id,
        MAX(civicrm_contribution.id)      AS last_fee_id
      FROM
        civicrm_membership
      LEFT JOIN
        civicrm_membership_payment ON civicrm_membership.id = civicrm_membership_payment.membership_id
      LEFT JOIN
        civicrm_contribution ON     civicrm_membership_payment.contribution_id = civicrm_contribution.id
                                AND civicrm_contribution.contribution_status_id = 1
                                AND civicrm_contribution.is_test = 0
      WHERE
        civicrm_membership.contact_id           IN (CONTACT_IDS)
      AND civicrm_membership.membership_type_id IN (%s)
      AND (%s)
      GROUP BY
        civicrm_membership.id;
      ";

      // TODO: status restrictions?

      // load all membership types
      $membership_types = array();
      $_membership_types = civicrm_api3('MembershipType', 'get', array('option.limit' => 99999));
      foreach ($_membership_types['values'] as $membership_type) {
        $membership_types[$membership_type['id']] = $membership_type;
      }

      // get $membership_type_id_list
      $membership_type_ids = array();
      if (isset($config->general_options->membership_type_ids)) {
        // if there is a given list, we'll take it
        $membership_type_ids_option = explode(',', $config->general_options->membership_type_ids);
        foreach ($membership_type_ids_option as $membership_type_id) {
          if ((int) $membership_type_id) {
            $membership_type_ids[] = (int) $membership_type_id;
          }
        }
      } else {
        // if there is no given list, we'll take all active type
        foreach ($membership_types as $membership_type_id => $membership_type) {
          if ($membership_type['is_active']) {
            $membership_type_ids[] = (int) $membership_type_id;
          }
        }
      }
      //if (empty($membership_type_ids)) throw Exception("matcher_membership: No active membership types found.");

      // compile $membership_type_clauses
      $membership_type_clauses = array();
      foreach ($membership_type_ids as $membership_type_id) {
        $amount_range = $this->getMembershipAmountRange($membership_types[$membership_type_id], $context);
        $membership_type_clauses[] = "(
          (civicrm_membership.membership_type_id = $membership_type_id)
          AND
          (BTX_AMOUNT >= ${amount_range[0]})
          AND
          (BTX_AMOUNT <= ${amount_range[1]})
          )";
      }

      // compile final query:
      error_log($base_query);
      $membership_type_id_list     = implode(',',    $membership_type_ids);
      $membership_type_clauses_sql = implode(' OR ', $membership_type_clauses);
      $query = sprintf($base_query, $membership_type_id_list, $membership_type_clauses_sql);

      // normalize query (remove extra whitespaces)
      $query = preg_replace('/\s+/', ' ', $query);

      // and cache the result
      CRM_Utils_StaticCache::setCachedEntry($cache_key, $query);
    }

    // insert the contact IDs
    $contact_id_list = implode(',', $contact_ids);
    $final_sql = str_replace('CONTACT_IDS', $contact_id_list, $query);
    $final_sql = str_replace('BTX_AMOUNT',  $amount,          $final_sql);
    error_log($final_sql);
    return $final_sql;
  }

  /**
   * This function will find out the amount range that would match the given type
   * 
   * @return array($min_amount, $max_amount, $exact_amount)
   */
  protected function getMembershipAmountRange($membership_type, $context) {
    $config = $this->_plugin_config;
    $expected_fee = (float) $this->getMembershipOption($membership_type['id'],
                                'membership_fee', $membership_type['minimum_fee']);
    $min_factor   = (float) $this->getMembershipOption($membership_type['id'],
                                'amount_min',     1.0);
    $max_factor   = (float) $this->getMembershipOption($membership_type['id'],
                                'amount_max',     1.0);
    return array($expected_fee * $min_factor, $expected_fee * $max_factor, $expected_fee);
  }

  /**
   * Helper function to get an option for a certain membership type id
   * These options can be specified in the general_options,
   * but overwritten int the membership_options.
   */
  protected function getMembershipOption($membership_type_id, $option_name, $default) {
    $config = $this->_plugin_config;
    $value = NULL;
    if (isset($config->general_options->$option_name)) {
      // get the value from the general_options
      $value = $config->general_options->$option_name;
    }
    if (isset($config->membership_options->$membership_type_id->$option_name)) {
      // overwrite if there's a specific option set for this type
      $value = $config->membership_options[$membership_type_id][$option_name];
    }
    if ($value === NULL) {
      return $default;
    } else {
      return $value;      
    }
  }

  /**
   * This function will evaluate the given membership instance data
   * wrt probability.
   * 
   * @return float [0..1]
   */
  protected function rateMembership(&$membership, $context) {
    error_log("RATING: " . print_r($membership,1));
    // TODO: implmement
    $membership['probability'] = 1.0;
    return $membership['probability'];
  }
}

